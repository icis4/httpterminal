<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>MIP Terminal</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    :root { color-scheme: light dark; }
    /* Make the page a column flex layout */
    body {
      font-family: system-ui, -apple-system, Segoe UI, Roboto, sans-serif;
      margin: 0;
      display: flex;
      flex-direction: column;
      min-height: 100vh;
    }
    /* Header bar */
    #header {
      display: flex;
      align-items: center;
      justify-content: center;
      padding: .75rem 1rem;
      border-bottom: 1px solid #ccc;
    }
    #header .title {
      font-size: 1.5rem;
      font-weight: 600;
      text-align: center;
    }

    /* App area */
    #app {
      display: flex;
      flex: 1 1 auto;
      min-height: 0;
    }

    #sidebar {
      width: 220px; padding: 1rem; border-right: 1px solid #ccc;
      display: flex; flex-direction: column; gap: .5rem;
    }
    #sidebar h2 { margin: .25rem 0; font-size: 1.05rem; }
    #sidebar button { width: 100%; padding: .5rem; cursor: pointer; }
    .muted { opacity: .7; font-size: .9em; }
    #historyList {
      display: flex; flex-direction: column; gap: .25rem; max-height: 40vh; overflow: auto; margin-top: .25rem;
    }
    .hist-item {
      text-align: left; padding: .35rem .5rem; border: 1px solid #8885; background: #f6f6f6;
      border-radius: .25rem; font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace;
    }
    @media (prefers-color-scheme: dark) {
      .hist-item { background: #1e1e1e; border-color: #555; color: #ddd; }
    }

    #main {
      flex: 1 1 auto;
      padding: 1rem;
      display: flex;
      flex-direction: column;
      min-height: 0;
    }

    /* Fixed-height log with scrollbars */
    #log {
      width: 100%;
      height: 65vh;      /* set to 65% of viewport height */
      box-sizing: border-box;
      white-space: pre-wrap;
      overflow: auto;    /* scrollbars when content expands */
      border: 1px solid #ccc;
      padding: .5rem;
      background: #000;
      color: #0f0;
      font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace;
    }

    #row { display: flex; gap: .5rem; margin-top: .5rem; flex-wrap: wrap; }
    input[type="text"] { flex: 1 1 320px; }
    .controls { display: flex; gap: .5rem; flex-wrap: wrap; align-items: center; }
    .spacer { flex: 1 1 auto; }
    button { cursor: pointer; }
    select, input[type="number"] { width: 8rem; }
    @media (max-width: 800px) {
      #sidebar { width: 180px; }
      select, input[type="number"] { width: 7rem; }
    }

    .section-title { margin: 0 0 .5rem 0; font-weight: 600; }
  </style>
</head>
<body>
  <header id="header" role="banner">
    <div class="title">MIP Terminal</div>
  </header>

  <div id="app">
    <aside id="sidebar">
      <h2>Commands</h2>
      <button id="cmd-id" title='Send "*IDN?"' disabled>ID</button>
      <button id="cmd-info" title='Send ":SYST:INFO"' disabled>INFO</button>
      <button id="cmd-rst" title='Send "*RST"' disabled>Reset</button>
      <hr />
      <h2>History</h2>
      <div class="muted">History records only text input (tx). Click to resend. Up/Down to recall.</div>
      <div id="historyList" aria-live="polite"></div>
      <button id="clearHistory">Clear history</button>
      <div class="muted">Buttons enable when connected.</div>
    </aside>

    <main id="main">
      <fieldset>
        <legend>Serial Connection</legend>
        <div class="controls">
          <label>Baud:
            <input id="baud" type="number" value="115200" min="50" step="50" />
          </label>
          <label>Data bits:
            <select id="databits">
              <option>8</option>
              <option selected>7</option>
            </select>
          </label>
          <label>Parity:
            <select id="parity">
              <option value="none">none</option>
              <option value="even">even</option>
              <option value="odd" selected>odd</option>
            </select>
          </label>
          <label>Stop bits:
            <select id="stopbits">
              <option>1</option>
              <option selected>2</option>
            </select>
          </label>
          <label>Flow:
            <select id="flow">
              <option value="none" selected>none</option>
              <option value="hardware">hardware (RTS/CTS)</option>
            </select>
          </label>
          <button id="connect">Connect…</button>
          <button id="disconnect" disabled>Disconnect</button>
        </div>
      </fieldset>

      <fieldset>
        <legend>TCP Connection (via WebSocket)</legend>
        <div class="controls">
          <label>Scheme:
            <select id="tcpScheme">
              <option value="ws">ws</option>
              <option value="wss" selected>wss</option>
            </select>
          </label>
          <label>Host:
            <input id="tcpHost" type="text" placeholder="example.com or 192.168.1.10" value="" />
          </label>
          <label>Port:
            <input id="tcpPort" type="number" min="1" max="65535" value="443" />
          </label>
          <label>Path:
            <input id="tcpPath" type="text" placeholder="/tcp" value="/tcp" />
          </label>
          <button id="tcpConnect">Connect</button>
          <button id="tcpDisconnect" disabled>Disconnect</button>
        </div>
        <div class="muted">
          Browsers cannot open raw TCP sockets. This connects to a WebSocket endpoint that relays to TCP.
          Example proxy: websocat ws-l:0.0.0.0:8080 tcp:127.0.0.1:5025 then use ws://host:8080/
        </div>
      </fieldset>

      <div id="status" class="muted" aria-live="polite"></div>

      <div id="log" aria-live="polite"></div>

      <div id="row">
        <input id="tx" type="text" placeholder="Type text to send" />
        <select id="eol" title="End-of-line to append on send">
          <option value="">No EOL</option>
          <option value="\n" selected>LF</option>
          <option value="\r">CR</option>
          <option value="\r\n">CRLF</option>
        </select>
        <button id="send">Send</button>
        <label><input id="echo" type="checkbox" checked /> Local echo</label>
        <label><input id="enterSend" type="checkbox" checked /> Enter sends</label>
        <label><input id="autoScroll" type="checkbox" checked /> Auto-scroll</label>
        <span class="spacer"></span>
        <button id="clear">Clear</button>
        <button id="save">Save log</button>
      </div>

      <p class="muted">
        Works in Chrome/Edge desktop. Requires HTTPS or localhost. Only one app can hold a serial port at a time.
      </p>
    </main>
  </div>

  <script>
    // Transport: serial or tcp (websocket proxy)
    let transport = 'none'; // 'none' | 'serial' | 'tcp'

    // Serial
    let port, reader, writer, reading = false;
    let textDecoder, textEncoder;

    // TCP/WebSocket
    let ws = null;

    // History (cookie-backed) — only for input #tx
    const HISTORY_COOKIE = 'mip_cmd_history';
    const HISTORY_MAX = 100;
    const HISTORY_SHOW = 20;
    let history = [];
    let historyIndex = -1;       // -1 = not navigating
    let draftBeforeNav = '';

    const $ = (id) => document.getElementById(id);
    const logEl = $('log');

    // Cookie utils (no regex to avoid escaping issues)
    function readCookie(name) {
      const prefix = name + '=';
      const parts = document.cookie ? document.cookie.split(';') : [];
      for (const part of parts) {
        const s = part.trim();
        if (s.startsWith(prefix)) {
          return decodeURIComponent(s.slice(prefix.length));
        }
      }
      return '';
    }
    function writeCookie(name, value, maxAgeSec) {
      document.cookie = name + '=' + encodeURIComponent(value) + '; path=/; max-age=' + maxAgeSec.toString();
    }
    function deleteCookie(name) {
      document.cookie = name + '=; path=/; max-age=0';
    }

    // History helpers
    function loadHistory() {
      try {
        const v = readCookie(HISTORY_COOKIE);
        if (!v) return [];
        const arr = JSON.parse(v);
        return Array.isArray(arr) ? arr.filter(s => typeof s === 'string') : [];
      } catch { return []; }
    }
    function saveHistory() {
      while (history.length > HISTORY_MAX) history.shift();
      try {
        writeCookie(HISTORY_COOKIE, JSON.stringify(history), 60 * 60 * 24 * 365);
      } catch {
        while (history.length > Math.min(25, HISTORY_MAX)) history.shift();
        try { writeCookie(HISTORY_COOKIE, JSON.stringify(history), 60 * 60 * 24 * 365); } catch {}
      }
    }
    function addToHistory(cmd) {
      const c = (cmd ?? '').trim();
      if (!c) return;
      if (history[history.length - 1] === c) return; // avoid immediate dup
      history.push(c);
      saveHistory();
      renderHistory();
    }
    function clearHistory() {
      history = [];
      deleteCookie(HISTORY_COOKIE);
      renderHistory();
    }
    function renderHistory() {
      const list = $('historyList');
      list.innerHTML = '';
      const start = Math.max(0, history.length - HISTORY_SHOW);
      for (let i = history.length - 1; i >= start; i--) {
        const cmd = history[i];
        const btn = document.createElement('button');
        btn.className = 'hist-item';
        btn.textContent = cmd;
        btn.title = 'Click to resend';
        btn.addEventListener('click', () => sendCommand(cmd)); // resend, but do NOT add to history again
        list.appendChild(btn);
      }
    }

    function setStatus(msg) { $('status').textContent = msg || ''; }
    function log(text) {
      logEl.textContent += text;
      if ($('autoScroll').checked) logEl.scrollTop = logEl.scrollHeight;
    }
    function eolValue() {
      return $('eol').value.replaceAll('\\r', '\r').replaceAll('\\n', '\n');
    }
    function setCommandButtonsEnabled(enabled) {
      $('cmd-id').disabled = !enabled;
      $('cmd-info').disabled = !enabled;
      $('cmd-rst').disabled = !enabled;
    }
    function isConnected() {
      return transport !== 'none';
    }

    // SERIAL
    async function connectSerial() {
      if (!('serial' in navigator)) {
        alert('Web Serial API not supported in this browser. Use Chrome or Edge (desktop).');
        return;
      }
      if (isConnected()) await disconnectAny();
      try {
        port = await navigator.serial.requestPort();
        const opts = {
          baudRate: parseInt($('baud').value, 10) || 115200,
          dataBits: parseInt($('databits').value, 10) || 7,
          stopBits: parseInt($('stopbits').value, 10) || 2,
          parity: $('parity').value || 'odd',
          flowControl: $('flow').value || 'none',
        };
        await port.open(opts);

        textDecoder = new TextDecoderStream();
        textEncoder = new TextEncoderStream();

        port.readable.pipeTo(textDecoder.writable).catch(() => {});
        textEncoder.readable.pipeTo(port.writable).catch(() => {});

        reader = textDecoder.readable.getReader();
        writer = textEncoder.writable.getWriter();

        $('connect').disabled = true;
        $('disconnect').disabled = false;
        $('tcpConnect').disabled = true;
        $('tcpDisconnect').disabled = true;

        transport = 'serial';
        setCommandButtonsEnabled(true);
        setStatus('Connected (Serial)');

        // Auto query on connect (not recorded in history)
        await sendCommand('*idn?');

        reading = true;
        (async () => {
          try {
            while (reading) {
              const { value, done } = await reader.read();
              if (done) break;
              if (value) log(value);
            }
          } catch (err) {
            console.error('Read error:', err);
            setStatus('Read error: ' + err.message);
          } finally {
            try { reader.releaseLock(); } catch {}
          }
        })();

      } catch (err) {
        console.error('Connect failed:', err);
        alert('Failed to connect: ' + err.message);
        setStatus('Disconnected');
        setCommandButtonsEnabled(false);
        transport = 'none';
        $('connect').disabled = false;
        $('disconnect').disabled = true;
        $('tcpConnect').disabled = false;
      }
    }

    async function disconnectSerial() {
      try {
        setStatus('Disconnecting serial…');
        reading = false;
        try { if (reader) await reader.cancel(); } catch {}
        try { if (writer) await writer.close(); } catch {}
        try { if (port?.readable) await port.readable.cancel(); } catch {}
        try { if (port?.writable) await port.writable.close(); } catch {}
        try { if (port) await port.close(); } catch {}
      } finally {
        $('connect').disabled = false;
        $('disconnect').disabled = true;
        $('tcpConnect').disabled = false;
        transport = 'none';
        setCommandButtonsEnabled(false);
        setStatus('Disconnected');
      }
    }

    // TCP (WebSocket proxy)
    function tcpUrlFromInputs() {
      const scheme = $('tcpScheme').value || 'wss';
      const host = ($('tcpHost').value || '').trim();
      const port = parseInt($('tcpPort').value, 10) || (scheme === 'wss' ? 443 : 80);
      let path = $('tcpPath').value || '/';
      if (!path.startsWith('/')) path = '/' + path;
      if (!host) return '';
      return `${scheme}://${host}:${port}${path}`;
    }

    async function connectTCP() {
      if (isConnected()) await disconnectAny();
      const url = tcpUrlFromInputs();
      if (!url) { alert('Please enter host, port, and path for the WebSocket.'); return; }
      try {
        setStatus('Connecting (TCP via WebSocket)…');
        ws = new WebSocket(url);
        ws.binaryType = 'arraybuffer';

        ws.addEventListener('open', async () => {
          transport = 'tcp';
          $('tcpConnect').disabled = true;
          $('tcpDisconnect').disabled = false;
          $('connect').disabled = true;
          $('disconnect').disabled = true;
          setCommandButtonsEnabled(true);
          setStatus('Connected (TCP via WebSocket)');

          // Auto query on connect (not recorded in history)
          await sendCommand('*idn?');
        });

        ws.addEventListener('message', (e) => {
          if (typeof e.data === 'string') {
            log(e.data);
          } else if (e.data instanceof ArrayBuffer) {
            try {
              log(new TextDecoder().decode(e.data));
            } catch {
              // Fallback: show as hex
              const bytes = new Uint8Array(e.data);
              log(Array.from(bytes).map(b => b.toString(16).padStart(2,'0')).join(' ') + '\n');
            }
          } else if (e.data instanceof Blob) {
            e.data.text().then(t => log(t)).catch(() => {});
          }
        });

        ws.addEventListener('error', (e) => {
          console.error('WebSocket error', e);
          setStatus('TCP/WebSocket error');
        });

        ws.addEventListener('close', () => {
          if (transport === 'tcp') {
            $('tcpConnect').disabled = false;
            $('tcpDisconnect').disabled = true;
            $('connect').disabled = false;
            setCommandButtonsEnabled(false);
            transport = 'none';
            setStatus('Disconnected (TCP)');
          }
        });
      } catch (err) {
        console.error('TCP connect failed:', err);
        alert('TCP connect failed: ' + err.message);
        setStatus('Disconnected');
        transport = 'none';
        $('tcpConnect').disabled = false;
        $('tcpDisconnect').disabled = true;
      }
    }

    async function disconnectTCP() {
      try {
        setStatus('Disconnecting TCP…');
        if (ws && ws.readyState === WebSocket.OPEN) {
          ws.close(1000, 'client closing');
        } else if (ws && (ws.readyState === WebSocket.CONNECTING || ws.readyState === WebSocket.CLOSING)) {
          try { ws.close(); } catch {}
        }
      } finally {
        ws = null;
        $('tcpConnect').disabled = false;
        $('tcpDisconnect').disabled = true;
        $('connect').disabled = false;
        setCommandButtonsEnabled(false);
        transport = 'none';
        setStatus('Disconnected');
      }
    }

    async function disconnectAny() {
      if (transport === 'serial') return disconnectSerial();
      if (transport === 'tcp') return disconnectTCP();
    }

    // Send helpers use current transport
    async function sendCore(text) {
      if (transport === 'serial' && writer) {
        await writer.write(text);
      } else if (transport === 'tcp' && ws && ws.readyState === WebSocket.OPEN) {
        ws.send(text);
      } else {
        setStatus('Not connected');
        throw new Error('Not connected');
      }
    }

    async function send() {
      if (!isConnected()) { setStatus('Not connected'); return; }
      const raw = $('tx').value;
      const text = raw + eolValue();
      try {
        await sendCore(text);
        addToHistory(raw); // only add from input tx
        if ($('echo').checked) log(text);
        $('tx').value = '';
        historyIndex = -1; draftBeforeNav = '';
        $('tx').focus();
      } catch (err) {
        console.error('Write error:', err);
        setStatus('Write error: ' + err.message);
      }
    }

    async function sendCommand(cmd) {
      if (!isConnected()) { setStatus('Not connected'); return; }
      const text = cmd + eolValue();
      try {
        await sendCore(text);
        // Do NOT add to history here (buttons and auto commands excluded)
        if ($('echo').checked) log(text);
      } catch (err) {
        console.error('Write error:', err);
        setStatus('Write error: ' + err.message);
      }
    }

    function clearLog() { logEl.textContent = ''; }

    function saveLog() {
      const blob = new Blob([logEl.textContent], { type: 'text/plain;charset=utf-8' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      const ts = new Date().toISOString().replace(/[:.]/g, '-');
      a.download = `serial-log-${ts}.txt`;
      document.body.appendChild(a);
      a.click();
      a.remove();
      URL.revokeObjectURL(url);
    }

    // Events
    $('connect').addEventListener('click', connectSerial);
    $('disconnect').addEventListener('click', disconnectSerial);

    $('tcpConnect').addEventListener('click', connectTCP);
    $('tcpDisconnect').addEventListener('click', disconnectTCP);

    $('send').addEventListener('click', send);
    $('clear').addEventListener('click', clearLog);
    $('save').addEventListener('click', saveLog);

    $('cmd-id').addEventListener('click', () => sendCommand('*IDN?'));
    $('cmd-info').addEventListener('click', () => sendCommand(':SYST:INFO'));
    $('cmd-rst').addEventListener('click', () => sendCommand('*RST'));

    // Arrow Up/Down history navigation in input
    $('tx').addEventListener('keydown', (e) => {
      if ($('enterSend').checked && e.key === 'Enter') {
        e.preventDefault();
        $('send').click();
        return;
      }
      if (e.key === 'ArrowUp') {
        e.preventDefault();
        if (history.length === 0) return;
        if (historyIndex === -1) {
          draftBeforeNav = $('tx').value;
          historyIndex = history.length - 1;
        } else {
          historyIndex = Math.max(0, historyIndex - 1);
        }
        $('tx').value = history[historyIndex] ?? '';
        $('tx').setSelectionRange($('tx').value.length, $('tx').value.length);
      } else if (e.key === 'ArrowDown') {
        e.preventDefault();
        if (history.length === 0) return;
        if (historyIndex === -1) {
          // nothing
        } else if (historyIndex < history.length - 1) {
          historyIndex++;
          $('tx').value = history[historyIndex] ?? '';
        } else {
          historyIndex = -1;
          $('tx').value = draftBeforeNav;
        }
        $('tx').setSelectionRange($('tx').value.length, $('tx').value.length);
      }
    });
    $('tx').addEventListener('input', () => {
      if (historyIndex !== -1) historyIndex = -1;
    });

    $('clearHistory').addEventListener('click', clearHistory);

    window.addEventListener('beforeunload', () => {
      disconnectAny();
    });

    // Init history on load
    history = loadHistory();
    renderHistory();
  </script>
</body>
</html>