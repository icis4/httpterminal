<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Melexis.IO</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <!-- Bootstrap 5 CDN -->
  <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/css/bootstrap.min.css" rel="stylesheet" integrity="sha384-QWTKZyjpPEjISv5WaRU9OFeRpok6YctnYmDr5pNlyT2bRjXh0JMhjY6hW+ALEwIH" crossorigin="anonymous">
  <style>
    :root { 
      color-scheme: light dark; 
      --theme-green: #198754; /* accent */
      --bg-green: #0A3622; /* deeper green background */
      --text-on-green: #f2f8f4;
      --panel-bg: rgba(255,255,255,0.06);
      --panel-bg-solid: #0f3a27;
      --panel-border: rgba(255,255,255,0.18);
      --muted-on-green: #c4d8ce;
    }
    /* Make the page a column flex layout */
    body {
      font-family: system-ui, -apple-system, Segoe UI, Roboto, sans-serif;
      margin: 0;
      display: flex;
      flex-direction: column;
      min-height: 100vh;
      background: var(--bg-green);
      color: var(--text-on-green);
    }
    /* Header bar */
    #header {
      display: flex;
      align-items: center;
      justify-content: center;
      padding: .75rem 1rem;
      border-bottom: 1px solid var(--panel-border);
      background: rgba(0,0,0,0.18);
      backdrop-filter: blur(3px);
    }
    #header .title {
      font-size: 1.5rem;
      font-weight: 600;
      text-align: center;
    }

    /* App area */
    #app {
      display: flex;
      flex: 1 1 auto;
      min-height: 0;
    }

  #sidebar h2 { margin: .25rem 0; font-size: 1.05rem; }
  .muted { opacity: 1; font-size: .8em; color: var(--muted-on-green); }
    #historyList {
      display: flex; flex-direction: column; gap: .25rem; max-height: 40vh; overflow: auto; margin-top: .25rem;
    }
    .hist-item {
      text-align: left; padding: .35rem .5rem; border: 1px solid var(--panel-border); background: var(--panel-bg);
      border-radius: .375rem; font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace;
      color: var(--text-on-green);
    }
    .hist-item:hover { background: rgba(255,255,255,0.12); }

    #main {
      flex: 1 1 auto;
      padding: 1rem;
      display: flex;
      flex-direction: column;
      min-height: 0;
    }
  fieldset { margin: 0 0 6px 0; background: var(--panel-bg); border:1px solid var(--panel-border); border-radius: .75rem; }
  legend { padding: 0 .5rem; font-weight:600; }
    .bootstrap-tabs { margin-top: 6px; }
    /* Remove custom tab styling (handled by Bootstrap) */
  .bootstrap-tabs .nav-link { cursor: pointer; }

    /* Fixed-height log with scrollbars */
    #log {
      width: 100%;
      height: 50vh;      /* reduced to 50% viewport height */
      max-height: calc(100vh - 260px); /* safeguard relative to other UI */
      box-sizing: border-box;
      white-space: pre-wrap;
      overflow: auto;    /* scrollbars when content expands */
      border: 1px solid var(--panel-border);
      padding: .5rem;
      background: #112d21; /* adjusted to harmonize with deeper bg */
      color: #d9dedc;       /* default: response (RX) gray */
      font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace;
    }

    /* Color coding for log entries */
  .log-echo { color: #4db2ff; }    /* brighter blue for local echo (TX) */
  .log-rx   { color: #d9dedc; }    /* light gray for device response (RX) */
  .log-okprompt { color: #59ffb0; }/* bright mint for "(OK)>" prompts */
  .log-badprompt { color: #ff7a7a; }/* softer red for non-OK prompts */
  .log-error { color: #ff5252; }   /* vivid error red */
    
    #row { display: flex; gap: .5rem; margin-top: .5rem; flex-wrap: wrap; }
    input[type="text"] { flex: 1 1 320px; }
  .controls { display: flex; gap: .5rem; flex-wrap: wrap; align-items: center; margin:4px; }
    .spacer { flex: 1 1 auto; }
    button { cursor: pointer; }
    button { cursor: pointer; }
    /* Themed elements */
  .btn-primary { background-color: #125f3d; border-color: #0f5235; }
  .btn-primary:hover, .btn-primary:focus { background-color: #0f5235; border-color: #0c452c; }
  .btn-secondary { background-color: #355846; border-color: #2b4638; color:#e6fff2; }
  .btn-secondary:hover { background-color: #2b4638; }
  .btn-success { background:#1e9d62; border-color:#198754; }
  .btn-success:hover { background:#198754; }
  .btn-outline-primary { color: #e6fff2; border-color: #59ffb0; }
  .btn-outline-primary:hover { background:#59ffb0; color:#08301f; }
  .btn-outline-danger { color: #ffc8c8; border-color: #ff7a7a; }
  .btn-outline-danger:hover { background:#ff7a7a; color:#300; }
  .btn-outline-secondary { color:#e2efe7; border-color:#88b6a1; }
  .btn-outline-secondary:hover { background:#88b6a1; color:#10241b; }
  .btn-outline-warning { color:#ffe8a6; border-color:#ffda6a; }
  .btn-outline-warning:hover { background:#ffda6a; color:#3a2d00; }
  .btn-outline-info { color:#c2ecff; border-color:#74d2ff; }
  .btn-outline-info:hover { background:#74d2ff; color:#002a38; }
  .nav-tabs { border-color: var(--panel-border); }
  .nav-tabs .nav-link { color: var(--text-on-green); }
  .nav-tabs .nav-link.active { background: rgba(0,0,0,0.35); color: #fff; border-color: var(--panel-border) var(--panel-border) transparent; }
  .tab-content { background: var(--panel-bg); border:1px solid var(--panel-border); border-top: none; padding: .75rem .75rem; border-radius: 0 0 .75rem .75rem; }
  .form-control, .form-select { background:#123d2a; border:1px solid #1d5a3d; color:#e6fff2; }
  .form-control:focus, .form-select:focus { background:#14452f; color:#fff; border-color:#59ffb0; box-shadow:0 0 0 .15rem rgba(89,255,176,0.25); }
  input::placeholder { color:#b7d5c6; }
  hr { border-color: var(--panel-border); }
    select, input[type="number"] { width: 8rem; }
    @media (max-width: 800px) {
      #sidebar { width: 180px; }
      select, input[type="number"] { width: 7rem; }
    }

    .section-title { margin: 0 0 .5rem 0; font-weight: 600; }
  </style>
</head>
<body>
  <header id="header" role="banner">
    <div class="title">Melexis.IO</div>
  </header>

  <div id="app">
    <!-- Sidebar removed: content moved to Terminal tab -->

    <main id="main">
      <fieldset>
        <div class="controls d-flex flex-wrap align-items-end gap-2">
          <label class="form-label mb-0">Baud:
            <input id="baud" class="form-control form-control-sm" type="number" value="115200" min="50" step="50" />
          </label>
          <label class="form-label mb-0">Data bits:
            <select id="databits" class="form-select form-select-sm">
              <option>8</option>
              <option selected>7</option>
            </select>
          </label>
          <label class="form-label mb-0">Parity:
            <select id="parity" class="form-select form-select-sm">
              <option value="none">none</option>
              <option value="even">even</option>
              <option value="odd" selected>odd</option>
            </select>
          </label>
          <label class="form-label mb-0">Stop bits:
            <select id="stopbits" class="form-select form-select-sm">
              <option>1</option>
              <option selected>2</option>
            </select>
          </label>
            <label class="form-label mb-0">Flow:
              <select id="flow" class="form-select form-select-sm">
                <option value="none" selected>none</option>
                <option value="hardware">hardware (RTS/CTS)</option>
              </select>
            </label>
          <button id="connect" class="btn btn-primary btn-sm">Connectâ€¦</button>
          <button id="disconnect" class="btn btn-secondary btn-sm" disabled>Disconnect</button>
          <span id="status" class="muted small"></span>
        </div>
      </fieldset>

      <ul class="nav nav-tabs bootstrap-tabs" id="mainTabs" role="tablist">
        <li class="nav-item" role="presentation">
          <button class="nav-link active" id="terminal-tab" data-bs-toggle="tab" data-bs-target="#tab1" type="button" role="tab" aria-controls="tab1" aria-selected="true">Terminal</button>
        </li>
        <li class="nav-item" role="presentation">
          <button class="nav-link" id="settings-tab" data-bs-toggle="tab" data-bs-target="#tab2" type="button" role="tab" aria-controls="tab2" aria-selected="false">Settings</button>
        </li>
        <li class="nav-item" role="presentation">
          <button class="nav-link" id="scan-tab" data-bs-toggle="tab" data-bs-target="#tab3" type="button" role="tab" aria-controls="tab3" aria-selected="false">Scan</button>
        </li>
        <li class="nav-item" role="presentation">
          <button class="nav-link" id="ir-tab" data-bs-toggle="tab" data-bs-target="#tab4" type="button" role="tab" aria-controls="tab4" aria-selected="false">IR Image</button>
        </li>
      </ul>
      <div class="tab-content pt-3" id="mainTabsContent">
      <div class="tab-pane fade show active" id="tab1" role="tabpanel" aria-labelledby="terminal-tab">
        <div style="display: flex; flex-wrap: wrap; gap: 2rem; align-items: flex-start;">
          <div style="flex:1 1 0;min-width:320px;">
            <div id="log" aria-live="polite"></div>
            <div id="row" class="d-flex flex-column gap-2">
              <div class="d-flex flex-nowrap align-items-stretch gap-1 w-100">
                <input id="tx" class="form-control form-control-sm" type="text" placeholder="Type text to send" />
                <button id="send" class="btn btn-success btn-sm">Send</button>
              </div>
              <div class="d-flex flex-wrap align-items-center gap-2 w-100">
                <select id="eol" class="form-select form-select-sm" title="End-of-line to append on send" style="max-width:90px;">
                  <option value="">No EOL</option>
                  <option value="\n" selected>LF</option>
                  <option value="\r">CR</option>
                  <option value="\r\n">CRLF</option>
                </select>
                <label class="form-check form-check-inline mb-0"><input id="echo" class="form-check-input" type="checkbox" checked /><span class="form-check-label"> Local echo</span></label>
                <label class="form-check form-check-inline mb-0"><input id="enterSend" class="form-check-input" type="checkbox" checked /><span class="form-check-label"> Enter sends</span></label>
                <label class="form-check form-check-inline mb-0"><input id="autoScroll" class="form-check-input" type="checkbox" checked /><span class="form-check-label"> Auto-scroll</span></label>
                <span class="spacer" style="flex:1 1 auto;"></span>
                <button id="clear" class="btn btn-outline-warning btn-sm">Clear</button>
                <button id="save" class="btn btn-outline-info btn-sm">Save log</button>
              </div>
            </div>
          </div>
          <div id="sidebar" style="min-width:200px;max-width:260px;flex:0 0 220px;padding:0 0 0 0.5rem;border:0;">
            <h2>Commands</h2>
            <button id="cmd-id" class="btn btn-outline-primary btn-sm w-100 mb-1" title='Send "*IDN?"' disabled>ID</button>
            <button id="cmd-info" class="btn btn-outline-primary btn-sm w-100 mb-1" title='Send ":SYST:INFO"' disabled>INFO</button>
            <button id="cmd-rst" class="btn btn-outline-danger btn-sm w-100 mb-2" title='Send "*RST"' disabled>Reset</button>
            <hr />
            <h2>History</h2>
            <div class="muted">History records only text input (tx). Click to resend. Up/Down to recall.</div>
            <div id="historyList" aria-live="polite"></div>
            <button id="clearHistory" class="btn btn-outline-secondary btn-sm w-100">Clear history</button>
            <div class="muted">Buttons enable when connected.</div>
          </div>
        </div>
      </div>
      <div class="tab-pane fade" id="tab2" role="tabpanel" aria-labelledby="settings-tab">
        <div class="p-3">
          <h5 class="mb-2">Serial Settings Persistence</h5>
          <p class="small mb-2">Baud rate, data bits, parity, stop bits, and flow control selections are automatically saved in your browser (localStorage) and restored the next time you open this page. Adjust them in the connection bar above; changes save instantly.</p>
          <div class="d-flex flex-wrap align-items-center gap-2 mb-2">
            <button id="resetSerialSettings" class="btn btn-outline-warning btn-sm">Reset to defaults</button>
          </div>
          <div id="currentSerialSettings" class="small text-muted" style="white-space:pre-line;"></div>
        </div>
      </div>
      <div class="tab-pane fade" id="tab3" role="tabpanel" aria-labelledby="scan-tab">
        <div class="p-3">Tab 3 content goes here.</div>
      </div>
      <div class="tab-pane fade" id="tab4" role="tabpanel" aria-labelledby="ir-tab">
        <div class="p-3" id="irContainer">
          <div class="d-flex flex-wrap align-items-start gap-3">
            <div>
              <canvas id="irCanvas" width="640" height="480" style="border:1px solid var(--panel-border);background:#000;border-radius:4px;image-rendering:pixelated;max-width:100%;height:auto;"></canvas>
              <div id="irTooltip" style="position:absolute;pointer-events:none;z-index:20;padding:4px 6px;background:rgba(0,0,0,0.75);color:#fff;font:12px system-ui;border:1px solid #59ffb0;border-radius:4px;display:none;white-space:nowrap;transform:translate(8px,8px);"></div>
            </div>
            <div class="d-flex flex-column align-items-center" style="min-width:60px;">
              <canvas id="irLegend" width="40" height="480" style="border:1px solid var(--panel-border);border-radius:4px;"></canvas>
              <div class="w-100 small mt-2" style="text-align:center;line-height:1.1;">
                <div id="irMax">40.0</div>
                <div style="height:4px;"></div>
                <div id="irMin">0.10</div>
              </div>
            </div>
          </div>
          <div class="mt-3 small d-flex flex-wrap align-items-center gap-3">
            <span>Grid: <span id="irGridSize">32Ã—24</span></span>
            <label class="form-label mb-0 d-flex align-items-center gap-1">Scale:
              <select id="irScaleSelect" class="form-select form-select-sm" style="max-width:70px;">
                <option value="1" selected>x1</option>
                <option value="2">x2</option>
                <option value="4">x4</option>
              </select>
            </label>
            <button id="irRead" class="btn btn-outline-primary btn-sm">Read</button>
            <button id="irContinuous" class="btn btn-outline-secondary btn-sm position-relative" data-active="0">Continuous</button>
            <span id="irRunning" style="width:10px;height:10px;border-radius:50%;background:#0d2219;box-shadow:0 0 4px #0d2219;transition:background-color .2s, box-shadow .2s;" title="Running status"></span>
            <button id="irSaveImage" class="btn btn-outline-info btn-sm">Save image</button>
            <button id="irExportData" class="btn btn-outline-secondary btn-sm">Export data</button>
          </div>
        </div>
      </div>
      </div>
      <p class="muted">
        Works in Chrome/Edge desktop. Requires HTTPS or localhost. Only one app can hold the port at a time.
      </p>
    </main>
  </div>

  <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/js/bootstrap.bundle.min.js" integrity="sha384-YvpcrYf0tY3lHB60NNkmXc5s9fDVZLESaAA55NDzOxhy9GkcIdslK1eN7N6jIeHz" crossorigin="anonymous"></script>
  <script>
    // Serial
    let port, reader, writer, reading = false;
  let textDecoder, textEncoder;
  let readableStreamClosed, writableStreamClosed;

    // History (cookie-backed) â€” only for input #tx
    const HISTORY_COOKIE = 'mip_cmd_history';
    const HISTORY_MAX = 100;
    const HISTORY_SHOW = 20;
    // Newest-first order: history[0] is most recent
    let history = [];
    let historyIndex = -1;       // -1 = not navigating
    let draftBeforeNav = '';

    const $ = (id) => document.getElementById(id);
    const logEl = $('log');

    /* ===== Serial settings persistence ===== */
    const SERIAL_SETTINGS_KEY = 'mip_serial_settings_v1';
    const SERIAL_DEFAULTS = { baud: 115200, databits: 7, parity: 'odd', stopbits: 2, flow: 'none' };

    function loadSerialSettings() {
      try {
        const raw = localStorage.getItem(SERIAL_SETTINGS_KEY);
        if (!raw) return { ...SERIAL_DEFAULTS };
        const obj = JSON.parse(raw);
        return { ...SERIAL_DEFAULTS, ...(obj && typeof obj === 'object' ? obj : {}) };
      } catch { return { ...SERIAL_DEFAULTS }; }
    }
    function saveSerialSettings(obj) {
      try { localStorage.setItem(SERIAL_SETTINGS_KEY, JSON.stringify(obj)); } catch {}
    }
    function currentSerialSettings() {
      return {
        baud: parseInt($('baud').value,10)||SERIAL_DEFAULTS.baud,
        databits: parseInt($('databits').value,10)||SERIAL_DEFAULTS.databits,
        parity: $('parity').value || SERIAL_DEFAULTS.parity,
        stopbits: parseInt($('stopbits').value,10)||SERIAL_DEFAULTS.stopbits,
        flow: $('flow').value || SERIAL_DEFAULTS.flow,
      };
    }
    function applySerialSettings(obj) {
      if (!obj) return;
      $('baud').value = obj.baud;
      $('databits').value = String(obj.databits);
      $('parity').value = obj.parity;
      $('stopbits').value = String(obj.stopbits);
      $('flow').value = obj.flow;
    }
    function updateSerialSettingsDisplay() {
      const el = $('currentSerialSettings');
      if (!el) return;
      const cur = currentSerialSettings();
      el.textContent = `Baud: ${cur.baud}\nData bits: ${cur.databits}\nParity: ${cur.parity}\nStop bits: ${cur.stopbits}\nFlow: ${cur.flow}`;
    }
    function persistAndDisplay() {
      saveSerialSettings(currentSerialSettings());
      updateSerialSettingsDisplay();
    }
    // Attach change listeners (delegated after DOM ready; elements already exist inline)
    ['baud','databits','parity','stopbits','flow'].forEach(id => {
      const el = $(id);
      if (el) el.addEventListener('change', persistAndDisplay);
      if (el && el.tagName === 'INPUT') el.addEventListener('input', persistAndDisplay);
    });
    // Load on startup
    const _loadedSerial = loadSerialSettings();
    applySerialSettings(_loadedSerial);
    // Provide reset button logic (in Settings tab)
    document.addEventListener('DOMContentLoaded', () => {
      const resetBtn = $('resetSerialSettings');
      if (resetBtn) resetBtn.addEventListener('click', () => {
        applySerialSettings(SERIAL_DEFAULTS);
        persistAndDisplay();
      });
      updateSerialSettingsDisplay();
    });

    // Cookie utils (no regex to avoid escaping issues)
    function readCookie(name) {
      const prefix = name + '=';
      const parts = document.cookie ? document.cookie.split(';') : [];
      for (const part of parts) {
        const s = part.trim();
        if (s.startsWith(prefix)) {
          return decodeURIComponent(s.slice(prefix.length));
        }
      }
      return '';
    }
    function writeCookie(name, value, maxAgeSec) {
      document.cookie = name + '=' + encodeURIComponent(value) + '; path=/; max-age=' + maxAgeSec.toString();
    }
    function deleteCookie(name) {
      document.cookie = name + '=; path=/; max-age=0';
    }

    // History helpers
    function loadHistory() {
      try {
        const v = readCookie(HISTORY_COOKIE);
        if (!v) return [];
        const arr = JSON.parse(v);
        return Array.isArray(arr) ? arr.filter(s => typeof s === 'string') : [];
      } catch { return []; }
    }
    function saveHistory() {
      // Trim oldest items (at the end) to cap size
      while (history.length > HISTORY_MAX) history.pop();
      try {
        writeCookie(HISTORY_COOKIE, JSON.stringify(history), 60 * 60 * 24 * 365);
      } catch {
        while (history.length > Math.min(25, HISTORY_MAX)) history.pop();
        try { writeCookie(HISTORY_COOKIE, JSON.stringify(history), 60 * 60 * 24 * 365); } catch {}
      }
    }
    function addToHistory(cmd) {
      const c = (cmd ?? '').trim();
      if (!c) return;
      if (history[0] === c) return; // avoid immediate dup (top)
      // Newest-first: add to the top
      history.unshift(c);
      saveHistory();
      renderHistory();
    }
    function clearHistory() {
      history = [];
      deleteCookie(HISTORY_COOKIE);
      renderHistory();
    }
    function renderHistory() {
      const list = $('historyList');
      list.innerHTML = '';
      const end = Math.min(history.length, HISTORY_SHOW);
      for (let i = 0; i < end; i++) {
        const cmd = history[i];
        const btn = document.createElement('button');
        btn.className = 'hist-item';
        btn.textContent = cmd;
        btn.title = 'Click to resend';
        btn.addEventListener('click', () => sendCommand(cmd)); // resend, but do NOT add to history again
        list.appendChild(btn);
      }
    }

    function setStatus(msg) { $('status').textContent = msg || ''; }

    // Logging helpers (span-based to support colors)
    function appendLog(text, cls) {
      if (!text) return;
      const span = document.createElement('span');
      if (cls) span.className = cls;
      span.textContent = text; // preserves newlines safely
      logEl.appendChild(span);
      if ($('autoScroll').checked) logEl.scrollTop = logEl.scrollHeight;
    }
    function logEcho(text) { appendLog(text, 'log-echo'); }
    function logError(text) { appendLog(text, 'log-error'); }

    // Stream RX processing: color prompts only at real start-of-line,
    // do not inject any markers. Works across chunk boundaries.
    let atLineStart = true;
    function processRx(text) {
      let i = 0;
      while (i < text.length) {
        // If at start of a line, check for prompt "(...)>"
        if (atLineStart) {
          const slice = text.slice(i);
          const m = slice.match(/^\(([^)]+)\)>/);
          if (m) {
            const cls = m[1] === 'OK' ? 'log-okprompt' : 'log-badprompt';
            appendLog(m[0], cls);
            i += m[0].length;
            atLineStart = false;
            continue;
          }
        }
        // Append up to and including next newline (if any)
        const nl = text.indexOf('\n', i);
        if (nl === -1) {
          appendLog(text.slice(i), 'log-rx');
          // atLineStart unchanged
          break;
        } else {
          appendLog(text.slice(i, nl + 1), 'log-rx'); // includes the newline
          i = nl + 1;
          atLineStart = true;
        }
      }
    }

    // Decode literal option values ("\n", "\r", "\r\n") into actual control chars
    function eolValue() {
      const v = $('eol').value;
      if (v === '\\n') return '\n';
      if (v === '\\r') return '\r';
      if (v === '\\r\\n') return '\r\n';
      return '';
    }
    function setCommandButtonsEnabled(enabled) {
      $('cmd-id').disabled = !enabled;
      $('cmd-info').disabled = !enabled;
      $('cmd-rst').disabled = !enabled;
    }

    async function connect() {
      if (!('serial' in navigator)) {
        alert('Web Serial API not supported in this browser. Use Chrome or Edge (desktop).');
        return;
      }
      try {
        // Always request a new port
        port = await navigator.serial.requestPort();
        const opts = {
          baudRate: parseInt($('baud').value, 10) || 115200,
          dataBits: parseInt($('databits').value, 10) || 7,
          stopBits: parseInt($('stopbits').value, 10) || 2,
          parity: $('parity').value || 'odd',
          flowControl: $('flow').value || 'none',
        };
        await port.open(opts);

  textDecoder = new TextDecoderStream();
  textEncoder = new TextEncoderStream();

  // Keep references to piping promises so we can await them on disconnect
  readableStreamClosed = port.readable.pipeTo(textDecoder.writable);
  writableStreamClosed = textEncoder.readable.pipeTo(port.writable);

        reader = textDecoder.readable.getReader();
        writer = textEncoder.writable.getWriter();

        $('connect').disabled = true;
        $('disconnect').disabled = false;
        setCommandButtonsEnabled(true);
        setStatus('Connected');

        // Auto query on connect (not recorded in history)
        await sendCommand('*idn?');

        reading = true;
        (async () => {
          try {
            while (reading) {
              const { value, done } = await reader.read();
              if (done) break;
              if (value) processRx(value);
            }
          } catch (err) {
            console.error('Read error:', err);
            setStatus('Read error: ' + err.message);
          } finally {
            try { reader.releaseLock(); } catch {}
          }
        })();

      } catch (err) {
        console.error('Connect failed:', err);
        alert('Failed to connect: ' + err.message);
        setStatus('Disconnected');
        setCommandButtonsEnabled(false);
      }
    }

    async function disconnect() {
      try {
        setStatus('Disconnectingâ€¦');
        reading = false;
        // Stop reading
        try {
          if (reader) {
            await reader.cancel();
            try { reader.releaseLock && reader.releaseLock(); } catch {}
          }
        } catch {}
        // Stop writing
        try {
          if (writer) {
            await writer.close();
            try { writer.releaseLock && writer.releaseLock(); } catch {}
          }
        } catch {}
        // Wait for the piping to finish
        try { if (readableStreamClosed) await readableStreamClosed.catch(() => {}); } catch {}
        try { if (writableStreamClosed) await writableStreamClosed.catch(() => {}); } catch {}
        // Finally close the port
        try { if (port) await port.close(); } catch {}
      } finally {
        // Do not set port to null, so it can be reused
        reader = null;
        writer = null;
        readableStreamClosed = null;
        writableStreamClosed = null;
        textDecoder = null;
        textEncoder = null;
        $('connect').disabled = false;
        $('disconnect').disabled = true;
        setCommandButtonsEnabled(false);
        setStatus('Disconnected');
      }
    }

    async function send() {
      if (!writer) { setStatus('Not connected'); return; }
      const raw = $('tx').value;
      const text = raw + eolValue();
      try {
        await writer.write(text);
        addToHistory(raw); // only add from input tx
        if ($('echo').checked) logEcho(text);
        $('tx').value = '';
        historyIndex = -1; draftBeforeNav = '';
        $('tx').focus();
      } catch (err) {
        console.error('Write error:', err);
        setStatus('Write error: ' + err.message);
      }
    }

    async function sendCommand(cmd) {
      if (!writer) { setStatus('Not connected'); return; }
      const text = cmd + eolValue();
      try {
        await writer.write(text);
        // Do NOT add to history here (buttons and auto commands excluded)
        if ($('echo').checked) logEcho(text);
      } catch (err) {
        console.error('Write error:', err);
        setStatus('Write error: ' + err.message);
      }
    }

    function clearLog() { logEl.textContent = ''; }

    function saveLog() {
      const blob = new Blob([logEl.textContent], { type: 'text/plain;charset=utf-8' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      const ts = new Date().toISOString().replace(/[:.]/g, '-');
      a.download = `serial-log-${ts}.txt`;
      document.body.appendChild(a);
      a.click();
      a.remove();
      URL.revokeObjectURL(url);
    }

    // Events
    $('connect').addEventListener('click', connect);
    $('disconnect').addEventListener('click', disconnect);
    $('send').addEventListener('click', send);
    $('clear').addEventListener('click', clearLog);
    $('save').addEventListener('click', saveLog);

    $('cmd-id').addEventListener('click', () => sendCommand('*IDN?'));
    $('cmd-info').addEventListener('click', () => sendCommand(':SYST:INFO'));
    $('cmd-rst').addEventListener('click', () => sendCommand('*RST'));

    // Arrow Up/Down history navigation in input (newest-first order)
    $('tx').addEventListener('keydown', (e) => {
      if ($('enterSend').checked && e.key === 'Enter') {
        e.preventDefault();
        $('send').click();
        return;
      }
      if (e.key === 'ArrowUp') {
        e.preventDefault();
        if (history.length === 0) return;
        if (historyIndex === -1) {
          draftBeforeNav = $('tx').value;
          historyIndex = 0; // most recent
        } else {
          historyIndex = Math.min(history.length - 1, historyIndex + 1); // go to older
        }
        $('tx').value = history[historyIndex] ?? '';
        $('tx').setSelectionRange($('tx').value.length, $('tx').value.length);
      } else if (e.key === 'ArrowDown') {
        e.preventDefault();
        if (history.length === 0) return;
        if (historyIndex === -1) {
          // nothing
        } else if (historyIndex > 0) {
          historyIndex--;
          $('tx').value = history[historyIndex] ?? '';
        } else {
          historyIndex = -1;
          $('tx').value = draftBeforeNav;
        }
        $('tx').setSelectionRange($('tx').value.length, $('tx').value.length);
      }
    });
    $('tx').addEventListener('input', () => {
      if (historyIndex !== -1) historyIndex = -1;
    });

    $('clearHistory').addEventListener('click', clearHistory);

    window.addEventListener('beforeunload', disconnect);

    // Init history on load
    history = loadHistory();
    renderHistory();
  // After history, ensure serial settings display is in sync if Settings tab viewed first
  updateSerialSettingsDisplay();

    /* ================= IR IMAGE (Heatmap) TAB ================= */
    const IR_ROWS = 24;
    const IR_COLS = 32;
    const IR_MIN = 0.10;
    const IR_MAX = 40.0;
    let irData = null; // Float32Array length IR_ROWS*IR_COLS
    let irInitialized = false;
  // Scaling / interpolation
  let irScale = 1; // allowed: 1 (nearest / block), 2, 4 (bicubic)
  const IR_BASE_CELL_SIZE = 20; // pixels per cell at scale 1

    function initIrData() {
      irData = new Float32Array(IR_ROWS * IR_COLS);
      randomizeIrData();
    }

    function randomizeIrData() {
      if (!irData) return;
      const span = IR_MAX - IR_MIN;
      for (let i = 0; i < irData.length; i++) {
        // Bias slightly toward middle for a more interesting distribution
        const r = (Math.random() + Math.random()) / 2; // triangular dist
        irData[i] = IR_MIN + span * r;
      }
    }

    // Piecewise thermal gradient stops
    const GRADIENT_STOPS = [
      [0.00, 0,   0,  64],
      [0.20, 0,   0, 255],
      [0.40, 0, 255, 255],
      [0.60, 255,255,   0],
      [0.80, 255,128,   0],
      [1.00, 255,255, 255]
    ];

    function lerp(a,b,t){return a + (b-a)*t;}
    function valueToColor(v) {
      let n = (v - IR_MIN) / (IR_MAX - IR_MIN);
      if (n < 0) n = 0; else if (n > 1) n = 1;
      // Find surrounding stops
      for (let i=0;i<GRADIENT_STOPS.length-1;i++) {
        const a = GRADIENT_STOPS[i];
        const b = GRADIENT_STOPS[i+1];
        if (n >= a[0] && n <= b[0]) {
          const t = (n - a[0])/(b[0]-a[0] || 1);
          const r = Math.round(lerp(a[1], b[1], t));
          const g = Math.round(lerp(a[2], b[2], t));
          const bC = Math.round(lerp(a[3], b[3], t));
          return [r,g,bC];
        }
      }
      const last = GRADIENT_STOPS[GRADIENT_STOPS.length-1];
      return [last[1], last[2], last[3]];
    }

    function drawIrHeatmap() {
      const canvas = $('irCanvas');
      if (!canvas || !irData) return;
      const ctx = canvas.getContext('2d');
      const w = canvas.width;
      const h = canvas.height;
      if (irScale === 1) {
        const cellW = w / IR_COLS;
        const cellH = h / IR_ROWS;
        const img = ctx.createImageData(w, h);
        const data = img.data;
        for (let row=0; row<IR_ROWS; row++) {
          for (let col=0; col<IR_COLS; col++) {
            const v = irData[row*IR_COLS + col];
            const [r,g,b] = valueToColor(v);
            const x0 = Math.floor(col * cellW);
            const y0 = Math.floor(row * cellH);
            const x1 = Math.floor((col+1) * cellW);
            const y1 = Math.floor((row+1) * cellH);
            for (let py=y0; py<y1; py++) {
              let idxBase = (py * w + x0) * 4;
              for (let px=x0; px<x1; px++) {
                data[idxBase++] = r;
                data[idxBase++] = g;
                data[idxBase++] = b;
                data[idxBase++] = 255;
              }
            }
          }
        }
        ctx.putImageData(img,0,0);
        canvas.style.imageRendering = 'pixelated';
        return;
      }
      // Bicubic interpolation for irScale > 1
      canvas.style.imageRendering = 'auto';
      const img = ctx.createImageData(w, h);
      const data = img.data;
      const gridW = IR_COLS;
      const gridH = IR_ROWS;
      function getVal(ix, iy) {
        if (ix < 0) ix = 0; else if (ix >= gridW) ix = gridW - 1;
        if (iy < 0) iy = 0; else if (iy >= gridH) iy = gridH - 1;
        return irData[iy * gridW + ix];
      }
      function cubic(p0,p1,p2,p3,t) {
        return 0.5 * (2*p1 + (-p0 + p2)*t + (2*p0 -5*p1 +4*p2 - p3)*t*t + (-p0 +3*p1 -3*p2 + p3)*t*t*t);
      }
      for (let y=0; y<h; y++) {
        const gy = (y / (h - 1)) * (gridH - 1);
        const iy = Math.floor(gy);
        const ty = gy - iy;
        for (let x=0; x<w; x++) {
          const gx = (x / (w - 1)) * (gridW - 1);
          const ix = Math.floor(gx);
          const tx = gx - ix;
          const colVals = new Array(4);
          for (let m=-1; m<=2; m++) {
            const rowVals = [
              getVal(ix-1, iy+m),
              getVal(ix,   iy+m),
              getVal(ix+1, iy+m),
              getVal(ix+2, iy+m)
            ];
            colVals[m+1] = cubic(rowVals[0], rowVals[1], rowVals[2], rowVals[3], tx);
          }
          const val = cubic(colVals[0], colVals[1], colVals[2], colVals[3], ty);
          const [r,g,b] = valueToColor(val);
          let idx = (y * w + x) * 4;
          data[idx] = r; data[idx+1] = g; data[idx+2] = b; data[idx+3] = 255;
        }
      }
      ctx.putImageData(img,0,0);
    }

    /* ===== IR Tooltip (raw + interpolated) ===== */
    const irTooltip = (() => {
      const el = document.getElementById('irTooltip');
      if (!el) return null;
      // Reuse interpolation helpers consistent with drawIrHeatmap
      function getVal(ix, iy) {
        if (ix < 0) ix = 0; else if (ix >= IR_COLS) ix = IR_COLS - 1;
        if (iy < 0) iy = 0; else if (iy >= IR_ROWS) iy = IR_ROWS - 1;
        return irData[iy * IR_COLS + ix];
      }
      function cubic(p0,p1,p2,p3,t){
        return 0.5 * (2*p1 + (-p0 + p2)*t + (2*p0 -5*p1 +4*p2 - p3)*t*t + (-p0 +3*p1 -3*p2 + p3)*t*t*t);
      }
      function sampleInterpolated(px, py, canvasW, canvasH) {
        if (!irData) return null;
        // Map pixel to grid space (same mapping used in bicubic loop)
        const gx = (px / (canvasW - 1)) * (IR_COLS - 1);
        const gy = (py / (canvasH - 1)) * (IR_ROWS - 1);
        const ix = Math.floor(gx);
        const iy = Math.floor(gy);
        const tx = gx - ix;
        const ty = gy - iy;
        // Raw nearest cell (for raw value display)
        const rawCol = Math.round(gx);
        const rawRow = Math.round(gy);
        let interpVal;
        if (irScale === 1) {
          interpVal = getVal(rawCol, rawRow);
        } else {
          const colVals = new Array(4);
          for (let m=-1; m<=2; m++) {
            const rowVals = [
              getVal(ix-1, iy+m),
              getVal(ix,   iy+m),
              getVal(ix+1, iy+m),
              getVal(ix+2, iy+m)
            ];
            colVals[m+1] = cubic(rowVals[0], rowVals[1], rowVals[2], rowVals[3], tx);
          }
            interpVal = cubic(colVals[0], colVals[1], colVals[2], colVals[3], ty);
        }
        return { rawRow, rawCol, rawVal: getVal(rawCol, rawRow), interpVal };
      }
      function fmt(v) { return v.toFixed(2); }
      function onMove(ev) {
        if (!irData) return;
        const canvas = $('irCanvas');
        if (!canvas) return;
        const rect = canvas.getBoundingClientRect();
        const x = ev.clientX - rect.left;
        const y = ev.clientY - rect.top;
        if (x < 0 || y < 0 || x >= rect.width || y >= rect.height) { el.style.display = 'none'; return; }
        const scaleX = canvas.width / rect.width;
        const scaleY = canvas.height / rect.height;
        const sample = sampleInterpolated(x * scaleX, y * scaleY, canvas.width, canvas.height);
        if (!sample) { el.style.display = 'none'; return; }
        el.style.display = 'block';
        el.textContent = `r${sample.rawRow} c${sample.rawCol}\nRaw: ${fmt(sample.rawVal)}\nInterp: ${fmt(sample.interpVal)}`;
        // Position near cursor but keep inside viewport
        const padding = 12;
        let left = ev.clientX + 12;
        let top = ev.clientY + 12;
        const vw = window.innerWidth;
        const vh = window.innerHeight;
        const estW = 120; // rough width
        const estH = 54; // rough height
        if (left + estW + padding > vw) left = ev.clientX - estW - 12;
        if (top + estH + padding > vh) top = ev.clientY - estH - 12;
        el.style.left = left + 'px';
        el.style.top = top + 'px';
      }
      function onLeave() { el.style.display = 'none'; }
      const canvas = $('irCanvas');
      if (canvas) {
        canvas.addEventListener('mousemove', onMove);
        canvas.addEventListener('mouseleave', onLeave);
      }
      return { update: ()=>{}, hide:onLeave };
    })();

    function drawIrLegend() {
      const canvas = $('irLegend');
      if (!canvas) return;
      const ctx = canvas.getContext('2d');
      const w = canvas.width, h = canvas.height;
      const img = ctx.createImageData(w, h);
      const data = img.data;
      for (let y=0; y<h; y++) {
        const n = 1 - (y / (h-1)); // top = 1 (max), bottom = 0 (min)
        const v = IR_MIN + (IR_MAX - IR_MIN) * n;
        const [r,g,b] = valueToColor(v);
        for (let x=0; x<w; x++) {
          const i = (y * w + x) * 4;
          data[i] = r; data[i+1] = g; data[i+2] = b; data[i+3] = 255;
        }
      }
      ctx.putImageData(img,0,0);
      // Optional ticks (every 20%)
      ctx.fillStyle = '#fff';
      ctx.font = '10px system-ui';
      ctx.textAlign = 'left';
      ctx.textBaseline = 'middle';
      for (let p=0; p<=1; p+=0.2) {
        const y = (1-p)* (h-1);
        ctx.fillRect(w-8, y, 8, 1);
      }
      $('irMax').textContent = IR_MAX.toFixed(1);
      $('irMin').textContent = IR_MIN.toFixed(2);
    }

    function renderIr() {
      updateIrCanvasSize();
      drawIrHeatmap();
      drawIrLegend();
    }

    function updateIrCanvasSize() {
      const canvas = $('irCanvas');
      const legend = $('irLegend');
      if (!canvas || !legend) return;
      // Keep base size constant; scale affects interpolation detail only
      const newW = IR_COLS * IR_BASE_CELL_SIZE;
      const newH = IR_ROWS * IR_BASE_CELL_SIZE;
      if (canvas.width !== newW || canvas.height !== newH) {
        canvas.width = newW; canvas.height = newH;
      }
      if (legend.height !== newH) legend.height = newH;
    }

    function ensureIrInitialized() {
      if (irInitialized) return;
      initIrData();
      renderIr();
  const readBtn = $('irRead');
  if (readBtn) readBtn.addEventListener('click', () => { randomizeIrData(); renderIr(); });
  const contBtn = $('irContinuous');
  if (contBtn) contBtn.addEventListener('click', toggleIrContinuous);
      const saveImgBtn = $('irSaveImage');
      if (saveImgBtn) saveImgBtn.addEventListener('click', saveIrImage);
      const exportBtn = $('irExportData');
      if (exportBtn) exportBtn.addEventListener('click', exportIrDataCsv);
      const scaleSel = $('irScaleSelect');
      if (scaleSel) scaleSel.addEventListener('change', () => {
        const v = parseInt(scaleSel.value, 10) || 1;
        irScale = (v === 2 || v === 4) ? v : 1;
        renderIr();
      });
      irInitialized = true;
    }

    // Continuous read (simulated by randomizeIrData for now)
    let irContinuousTimer = null;
    function toggleIrContinuous() {
      const btn = $('irContinuous');
      const ind = $('irRunning');
      if (!btn) return;
      const active = btn.getAttribute('data-active') === '1';
      if (active) {
        // stop
        btn.setAttribute('data-active','0');
        btn.classList.remove('btn-success');
        btn.classList.add('btn-outline-secondary');
        if (irContinuousTimer) { clearInterval(irContinuousTimer); irContinuousTimer = null; }
        if (ind) { ind.style.background = '#0d2219'; ind.style.boxShadow = '0 0 4px #0d2219'; }
      } else {
        // start
        btn.setAttribute('data-active','1');
        btn.classList.remove('btn-outline-secondary');
        btn.classList.add('btn-success');
        // immediate read
        randomizeIrData(); renderIr();
        irContinuousTimer = setInterval(() => {
          randomizeIrData();
          renderIr();
        }, 500);
        if (ind) { ind.style.background = '#59ffb0'; ind.style.boxShadow = '0 0 6px #59ffb0'; }
      }
    }
    // Stop continuous when leaving page or tab hidden
    document.addEventListener('visibilitychange', () => {
      if (document.hidden) {
        if (irContinuousTimer) { clearInterval(irContinuousTimer); irContinuousTimer = null; }
        const btn = $('irContinuous');
        const ind = $('irRunning');
        if (btn && btn.getAttribute('data-active') === '1') {
          btn.setAttribute('data-active','0');
          btn.classList.remove('btn-success');
          btn.classList.add('btn-outline-secondary');
          if (ind) { ind.style.background = '#0d2219'; ind.style.boxShadow = '0 0 4px #0d2219'; }
        }
      }
    });
    window.addEventListener('beforeunload', () => { if (irContinuousTimer) clearInterval(irContinuousTimer); });

    // Render when IR tab is shown first time
    document.addEventListener('shown.bs.tab', (ev) => {
      if (ev.target && ev.target.id === 'ir-tab') {
        ensureIrInitialized();
      }
    });

    // If user bookmarked directly with hash #tab4, initialize
    if (location.hash === '#tab4') {
      ensureIrInitialized();
    }

    /* ===== Export Helpers ===== */
    function exportIrDataCsv() {
      if (!irData) return;
      let lines = [];
      lines.push('rows,'+IR_ROWS+',cols,'+IR_COLS+',min,'+IR_MIN+',max,'+IR_MAX);
      for (let r=0;r<IR_ROWS;r++) {
        let rowVals = [];
        for (let c=0;c<IR_COLS;c++) {
          rowVals.push(irData[r*IR_COLS + c].toFixed(2));
        }
        lines.push(rowVals.join(','));
      }
      const blob = new Blob([lines.join('\n')], {type:'text/csv'});
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = 'ir-data-'+Date.now()+'.csv';
      document.body.appendChild(a); a.click(); a.remove();
      URL.revokeObjectURL(url);
    }

    function saveIrImage() {
      const heat = $('irCanvas');
      const legend = $('irLegend');
      if (!heat || !legend) return;
      // Create composite canvas: place heatmap left, legend right with small gap + labels
      const gap = 8;
      const labelSpace = 30; // space on right for min/max text if desired
      // Use current (possibly scaled) canvas dimensions
      const outW = heat.width + gap + legend.width + labelSpace;
      const outH = Math.max(heat.height, legend.height);
      const cv = document.createElement('canvas');
      cv.width = outW; cv.height = outH;
      const ctx = cv.getContext('2d');
      // Fill background dark
      ctx.fillStyle = '#000';
      ctx.fillRect(0,0,outW,outH);
      ctx.drawImage(heat, 0, 0);
      // Scale legend vertically if different height
      ctx.drawImage(legend, heat.width + gap, 0, legend.width, heat.height);
      // Draw border around legend
      ctx.strokeStyle = '#ccc';
      ctx.strokeRect(heat.width + gap + 0.5, 0.5, legend.width-1, heat.height-1);
      // Labels (Max at top, Min at bottom)
      ctx.fillStyle = '#fff';
      ctx.font = '16px system-ui';
      ctx.textAlign = 'left';
      ctx.fillText(IR_MAX.toFixed(1), heat.width + gap + legend.width + 4, 18);
      ctx.fillText(IR_MIN.toFixed(2), heat.width + gap + legend.width + 4, heat.height - 6);
      // Title
      ctx.font = '18px system-ui';
      ctx.textAlign = 'center';
      ctx.fillText('IR Image ('+IR_COLS+'x'+IR_ROWS+')', heat.width/2, 24);
      // Download
      cv.toBlob(blob => {
        if (!blob) return;
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = 'ir-image-'+Date.now()+'.png';
        document.body.appendChild(a); a.click(); a.remove();
        URL.revokeObjectURL(url);
      }, 'image/png');
    }
  </script>
</body>
</html>
